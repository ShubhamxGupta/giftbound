'use server'

import { createClient } from '@supabase/supabase-js'
import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'
import { Participant } from '@/lib/types'

// Initialize Supabase Admin Client for Server Actions
function getSupabaseAdmin() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error('Missing Supabase Environment Variables. Check .env.local')
  }
  return createClient(supabaseUrl, supabaseServiceKey)
}

export async function createEvent(formData: {
  name: string
  date: string
  budget: string
  participants: { name: string; email: string }[]
}) {
  const supabaseAdmin = getSupabaseAdmin()
  const creator = formData.participants[0]
  
  // Generate simple 6-char code
  const joinCode = Math.random().toString(36).substring(2, 8).toUpperCase()

  // 1. Create Event
  const { data: event, error: eventError } = await supabaseAdmin
    .from('events')
    .insert({
      name: formData.name,
      join_code: joinCode,
      date: formData.date || null,
      budget: formData.budget || null,
      creator_email: creator.email,
      status: 'DRAFT'
    })
    .select()
    .single()

  if (eventError || !event) {
    console.error('Error creating event:', eventError)
    throw new Error('Failed to create event')
  }

  // 2. Add Participants
  const participantsData = formData.participants.map((p, index) => ({
    event_id: event.id,
    name: p.name,
    email: p.email,
    is_organizer: index === 0,
    // magic_token and id are auto-generated by DB
  }))

  const { data: participants, error: partError } = await supabaseAdmin
    .from('participants')
    .insert(participantsData)
    .select()

  if (partError) {
    console.error('Error adding participants:', partError)
    // Cleanup event? 
    throw new Error('Failed to add participants')
  }

  // 3. Retrieve the Creator's Magic Link/ID to redirect request
  const creatorParticipant = participants.find(p => p.is_organizer)
  
  if (creatorParticipant) {
     redirect(`/event/${event.id}?token=${creatorParticipant.magic_token}`)
  }
  
  return { success: true, eventId: event.id }
}

export async function getEventData(eventId: string, token: string) {
  const supabaseAdmin = getSupabaseAdmin()
  // 1. Verify Token
  const { data: participant } = await supabaseAdmin
    .from('participants')
    .select('*')
    .eq('event_id', eventId)
    .eq('magic_token', token)
    .single()

  if (!participant) return null

  // 2. Get Event
  const { data: event } = await supabaseAdmin
    .from('events')
    .select('*')
    .eq('id', eventId)
    .single()
    
  // 3. Get Assignment (if exists)
  let assignment = null
  if (participant.assigned_participant_id) {
    const { data: target } = await supabaseAdmin
      .from('participants')
      .select('name, wishlist')
      .eq('id', participant.assigned_participant_id)
      .single()
    assignment = target
  }

  // 4. Get all participants (public info: name, status) for the dashboard list
  const { data: allParticipants } = await supabaseAdmin
    .from('participants')
    .select('id, name, status, is_organizer') // Exclude sensitive info
    .eq('event_id', eventId)

  return { event, participant, assignment, allParticipants }
}

export async function shuffleEvent(eventId: string) {
  const supabaseAdmin = getSupabaseAdmin()
  // 1. Fetch participants
  const { data: participants } = await supabaseAdmin
    .from('participants')
    .select('id')
    .eq('event_id', eventId)

  if (!participants || participants.length < 2) {
    throw new Error('Need at least 2 participants to shuffle')
  }

  const ids = participants.map(p => p.id)
  
  // 2. Derangement Shuffle (Sattolo's or Rejection Sampling)
  // Simple Rejection Sampling for N < 100 is fine
  let shuffled = [...ids]
  let valid = false
  let attempts = 0
  
  while (!valid && attempts < 100) {
    // Fisher-Yates Shuffle
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    
    // Check Derangement (no index i s.t. shuffled[i] == ids[i])
    // AND Check exclusions (if implemented). simple self-check for now.
    valid = ids.every((id, i) => id !== shuffled[i])
    attempts++
  }

  if (!valid) {
    // Fallback: Just rotate array by 1 (guaranteed derangement for simple case)
    // A -> B -> C -> A
    shuffled = [...ids.slice(1), ids[0]]
  }

  // 3. Update DB
  // We need to update each participant. 
  // In a real app, use a batch RPC or transaction.
  // Here we do parallel updates.
  const updates = ids.map((id, index) => {
    return supabaseAdmin
      .from('participants')
      .update({ 
        assigned_participant_id: shuffled[index],
        status: 'JOINED' // Mark as ready
      })
      .eq('id', id)
  })

  await Promise.all(updates)

  // 4. Update Event Status
  await supabaseAdmin
    .from('events')
    .update({ status: 'ACTIVE' })
    .eq('id', eventId)

  // 5. Mock Email Sending
  // console.log("Sending emails to...")

  revalidatePath(`/event/${eventId}`)
  return { success: true }
}

export async function joinEvent(joinCode: string, name: string, email: string) {
  const supabaseAdmin = getSupabaseAdmin()

  // 1. Find Event
  const { data: event } = await supabaseAdmin
    .from('events')
    .select('id, status')
    .eq('join_code', joinCode.toUpperCase())
    .single()

  if (!event) throw new Error('Invalid Room Code')
  
  // 2. Lookup existing participant by email
  const { data: participant } = await supabaseAdmin
    .from('participants')
    .select('*')
    .eq('event_id', event.id)
    .eq('email', email)
    .single()

  if (!participant) {
      throw new Error('This email is not on the guest list of this event.')
  }
  
  // 3. Mark as Joined (if not already?) - Status update is handled by shuffle
  
  redirect(`/event/${event.id}?token=${participant.magic_token}`)
}

export async function updateWishlist(token: string, wishlist: string) {
  const supabaseAdmin = getSupabaseAdmin()
  // Verify token and get event_id for revalidation
  const { data: p } = await supabaseAdmin
    .from('participants')
    .select('event_id')
    .eq('magic_token', token)
    .single()

  if (!p) throw new Error('Invalid token')

  await supabaseAdmin
    .from('participants')
    .update({ wishlist })
    .eq('magic_token', token)

  revalidatePath(`/event/${p.event_id}`)
  return { success: true }
}

export async function checkUpdates(token: string, currentAssignmentId: string | null, currentStatus: string) {
  const supabaseAdmin = getSupabaseAdmin()
  
  const { data: p } = await supabaseAdmin
    .from('participants')
    .select('assigned_participant_id, events(status)')
    .eq('magic_token', token)
    .single()
    
  if (!p) return { changed: false }
  
  const newStatus = (p.events as any).status
  const newAssignmentId = p.assigned_participant_id

  // Trigger update if:
  // 1. Event Status Changed (e.g. DRAFT -> ACTIVE)
  // 2. Assignment ID changed (Reshuffle)
  const statusChanged = newStatus !== currentStatus
  const assignmentChanged = newAssignmentId !== currentAssignmentId
  
  if (statusChanged || assignmentChanged) {
      console.log(`Update detected for ${token}: Status ${currentStatus}->${newStatus}, Asg ${currentAssignmentId}->${newAssignmentId}`)
  }
  
  return { 
    changed: statusChanged || assignmentChanged,
    status: newStatus
  }
}
